{% extends "base.html" %}

{% block title %}Review - Rutabaga QA{% endblock %}

{% block content %}
<div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Stats Bar -->
    <div id="stats-bar"
         class="bg-white rounded-lg shadow-sm p-4 mb-6 flex justify-between items-center"
         hx-get="{{ url_for('api.session_stats') }}"
         hx-trigger="load, refresh from:body"
         hx-swap="none">
        <div>
            <span class="text-sm text-gray-600">Session:</span>
            <span class="font-semibold text-gray-900" id="session-count">0</span>
            <span class="text-sm text-gray-600">reviews</span>
        </div>
        <div>
            <span class="text-sm text-gray-600">All-time:</span>
            <span class="font-semibold text-gray-900" id="total-count">{{ current_user.total_reviews_submitted }}</span>
            <span class="text-sm text-gray-600">reviews</span>
        </div>
    </div>

    <!-- Intent Selector -->
    <div class="bg-white rounded-lg shadow-sm p-4 mb-6">
        <label class="block text-sm font-medium text-gray-700 mb-2">Select Intent</label>
        <select name="intent"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                hx-get="{{ url_for('api.get_next_response') }}"
                hx-target="#review-form"
                hx-swap="innerHTML"
                hx-include="this">
            <option value="" selected disabled>-- Select an intent to review --</option>
            <option value="interaction">Interaction</option>
            <option value="dosing">Dosing</option>
            <option value="drug_dose_rsi">Drug Dose RSI</option>
            <option value="bp_target">BP Target</option>
            <option value="contraindication">Contraindication</option>
            <option value="pregnancy">Pregnancy</option>
            <option value="lactation">Lactation</option>
            <option value="renal_dosing">Renal Dosing</option>
            <option value="hepatic_dosing">Hepatic Dosing</option>
            <option value="pediatric_dosing">Pediatric Dosing</option>
            <option value="iv_compatibility">IV Compatibility</option>
            <option value="calculator">Calculator</option>
        </select>
    </div>

    <!-- Review Form -->
    <div id="review-form" class="bg-white rounded-lg shadow-sm p-6">
        <div class="text-center text-gray-500 py-12">
            <p class="text-lg mb-2">Select an intent to start reviewing</p>
            <p class="text-sm">Responses will auto-load when available</p>
        </div>
    </div>
</div>

<script>
// Update stats when HTMX fetches session stats
document.body.addEventListener('htmx:afterSwap', function(evt) {
    if (evt.detail.xhr) {
        try {
            const response = JSON.parse(evt.detail.xhr.responseText);
            if (response.session_reviews !== undefined) {
                document.getElementById('session-count').textContent = response.session_reviews;
                document.getElementById('total-count').textContent = response.total_reviews;
            }
        } catch (e) {
            // Not JSON, ignore
        }
    }
});

// Global reviewForm function for Alpine.js
window.reviewForm = function(responseId, segments, previousReview) {
    return {
        responseId: responseId,
        showSourceData: false,
        sourceData: null,
        loadingSourceData: false,
        overallNotes: '',
        showPreviousReview: false,
        previousReview: previousReview || {},
        scores: segments.reduce((acc, seg) => {
            acc[seg.id] = { score: null, suggestion: '' };
            return acc;
        }, {}),

        async toggleSourceData() {
            this.showSourceData = !this.showSourceData;

            // Fetch source data if not already loaded
            if (this.showSourceData && !this.sourceData && !this.loadingSourceData) {
                this.loadingSourceData = true;
                try {
                    const response = await fetch(`/api/source-data/${this.responseId}`);
                    const data = await response.json();
                    if (data.success) {
                        this.sourceData = data.source_data;
                    }
                } catch (error) {
                    console.error('Error fetching source data:', error);
                } finally {
                    this.loadingSourceData = false;
                }
            }
        },

        canSubmit() {
            // All segments must have a score
            return Object.values(this.scores).every(s => s.score !== null);
        },

        getSegmentScores() {
            return this.scores;
        },

        async skip() {
            try {
                const response = await fetch('/api/review/skip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ response_id: this.responseId })
                });

                if (response.ok) {
                    this.loadNext();
                } else {
                    const error = await response.json();
                    alert(`Error skipping: ${error.error || 'Unknown error'}`);
                    console.error('Skip failed:', error);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                console.error('Skip error:', error);
            }
        },

        async flag() {
            const reason = prompt('Why are you flagging this response?\n\n(e.g., "Incorrect slots", "Bad ingestion", "Other issue")');
            if (!reason) return;

            try {
                const response = await fetch('/api/review/flag', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        response_id: this.responseId,
                        flag_reason: reason,
                        segment_scores: this.getSegmentScores(),
                        overall_notes: this.overallNotes
                    })
                });

                if (response.ok) {
                    alert('Response flagged for admin review');
                    this.loadNext();
                } else {
                    const error = await response.json();
                    alert(`Error flagging: ${error.error || 'Unknown error'}`);
                    console.error('Flag failed:', error);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                console.error('Flag error:', error);
            }
        },

        async saveDraft() {
            try {
                const response = await fetch('/api/review/draft', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        response_id: this.responseId,
                        segment_scores: this.getSegmentScores(),
                        overall_notes: this.overallNotes
                    })
                });

                if (response.ok) {
                    alert('Draft saved successfully');
                    this.loadNext();
                } else {
                    const error = await response.json();
                    alert(`Error saving draft: ${error.error || 'Unknown error'}`);
                    console.error('Save draft failed:', error);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                console.error('Save draft error:', error);
            }
        },

        async submit() {
            if (!this.canSubmit()) {
                alert('Please score all segments before submitting');
                return;
            }

            try {
                const response = await fetch('/api/review/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        response_id: this.responseId,
                        segment_scores: this.getSegmentScores(),
                        overall_notes: this.overallNotes
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Show success toast
                    this.showToast(data.message);
                    // Update stats
                    htmx.trigger('#stats-bar', 'refresh');
                    // Load next
                    this.loadNext();
                } else {
                    alert(`Error submitting: ${data.message || 'Unknown error'}`);
                    console.error('Submit failed:', data);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                console.error('Submit error:', error);
            }
        },

        loadNext() {
            // Trigger HTMX to load next response
            const intent = document.querySelector('select[name="intent"]').value;
            htmx.ajax('GET', `/api/next-response?intent=${intent}`, '#review-form');
        },

        showToast(message) {
            // Simple toast notification
            const toast = document.createElement('div');
            toast.className = 'fixed bottom-4 right-4 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
    }
};
</script>
{% endblock %}
